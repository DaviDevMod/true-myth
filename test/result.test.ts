import { assertType } from './lib/assert';
import * as Result from '../src/result';

describe('`Result` static methods', () => {
  test('`ok`', () => {
    expect('to be implemented').toBe(false);
  });

  test('`err`', () => {
    expect('to be implemented').toBe(false);
  });

  test('`map`', () => {
    expect('to be implemented').toBe(false);
  });

  test('`mapOr`', () => {
    expect('to be implemented').toBe(false);
  });

  test('`mapOrElse`', () => {
    expect('to be implemented').toBe(false);
  });

  test('`mapErr`', () => {
    expect('to be implemented').toBe(false);
  });

  test('`and`', () => {
    expect('to be implemented').toBe(false);
  });

  test('`andThen`', () => {
    expect('to be implemented').toBe(false);
  });

  test('`or`', () => {
    expect('to be implemented').toBe(false);
  });

  test('`orElse`', () => {
    expect('to be implemented').toBe(false);
  });

  test('`unwrap`', () => {
    expect('to be implemented').toBe(false);
  });

  test('`unwrapErr`', () => {
    expect('to be implemented').toBe(false);
  });

  test('`unwrapOrElse`', () => {
    expect('to be implemented').toBe(false);
  });

  test('`toMaybe`', () => {
    expect('to be implemented').toBe(false);
  });
});

test('`Result.Ok` class', () => {
  expect('to be implemented').toBe(false);
});

test('`Result.Err` class', () => {
  expect('to be implemented').toBe(false);
});
